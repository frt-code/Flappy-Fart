<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Flappy Fart</title>
  <style>
    :root{
      --bg:#0e1a14;
      --frame:#7ad0d6;
    }
    html,body{height:100%;margin:0;background:var(--frame);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{display:grid;place-items:center;}
    .wrap{
      width:min(460px,92vw);
      aspect-ratio: 9/16;
      background:rgba(0,0,0,0.15);
      border-radius:22px;
      box-shadow: 0 24px 80px rgba(0,0,0,.45);
      padding:14px;
    }
    canvas{
      width:100%;
      height:100%;
      border-radius:18px;
      background:var(--bg);
      display:block;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
      touch-action: manipulation;
    }
    .hint{
      position:fixed;left:-9999px;top:-9999px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="450" height="800" aria-label="Flappy Fart"></canvas>
  </div>

<script>
/* =========================
   Flappy Fart — single file
   ========================= */

// ---------- Config ----------
const W = 450;
const H = 800;

const TUNING = {
  // motion
  gravity: 0.52,
  flapImpulse: -8.8,
  pipeSpeed: 3.35,
  spawnEvery: 1250,      // ms
  gap: 210,              // gap size
  pipeW: 96,

  // toilet "cap" hitbox (the toilet head)
  capW: 132,
  capH: 54,
  capInset: 18,          // how far cap overlaps into gap (bigger => harder)

  // difficulty limits
  minGap: 150,
  maxSpeed: 5.4,

  // visuals
  puffEvery: 70,         // ms between puffs while playing
  puffLife: 680,         // ms
};

const UI = {
  topBarH: 62,
  cardW: 360,
  cardH: 360,
  cardR: 18
};

const STORAGE = {
  best: "flappyfart_best_v2",
  board: "flappyfart_board_v2",
  name: "ff_name_v1",
};

// ---------- Global Leaderboard (SheetBest) ----------
const SHEETBEST_URL = "https://api.sheetbest.com/sheets/0815363c-4408-4c6f-a17f-5be927d638de";

let globalBoard = [];
let globalBoardStatus = "loading";

async function fetchGlobalBoard(){
  globalBoardStatus = "loading";
  try{
    const res = await fetch(SHEETBEST_URL, { cache: "no-store" });
    const rows = await res.json();

    globalBoard = rows
      .map(r => ({ name: (r.name || "anon"), score: Number(r.score || 0) }))
      .filter(r => Number.isFinite(r.score))
      .sort((a,b)=>b.score-a.score)
      .slice(0,10);

    globalBoardStatus = "ready";
  }catch(e){
    globalBoardStatus = "error";
  }
}

async function submitGlobalScore(name, score){
  try{
    await fetch(SHEETBEST_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({
        name: (name || "anon").slice(0,16),
        score,
        created_at: new Date().toISOString()
      })
    });
    fetchGlobalBoard();
  }catch(e){
    // ignore
  }
}

function getPlayerName(){
  let n = localStorage.getItem(STORAGE.name);
  if(!n){
    n = prompt("Name for global leaderboard:", "anon") || "anon";
    n = n.trim() || "anon";
    localStorage.setItem(STORAGE.name, n.slice(0,16));
  }
  return n;
}

// ---------- Canvas ----------
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// ---------- Audio (simple fart synth) ----------
let audioCtx = null;
function fartSound(){
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();

    osc.type = "square";
    osc.frequency.setValueAtTime(160, t);
    osc.frequency.exponentialRampToValueAtTime(55, t + 0.09);

    filt.type = "lowpass";
    filt.frequency.setValueAtTime(900, t);
    filt.frequency.exponentialRampToValueAtTime(180, t + 0.12);

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.22, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);

    osc.connect(filt);
    filt.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(t);
    osc.stop(t + 0.18);
  }catch(e){}
}

// ---------- Game State ----------
let state = "ready"; // ready | playing | dead
let score = 0;
let pipes = [];
let puffs = [];
let lastSpawn = 0;
let lastPuff = 0;

const bird = {
  x: 145,
  y: H*0.5,
  r: 22,
  v: 0
};

function reset(){
  state = "ready";
  score = 0;
  pipes = [];
  puffs = [];
  bird.x = 145;
  bird.y = H*0.5;
  bird.v = 0;
  lastSpawn = performance.now();
  lastPuff = performance.now();
}

function startPlaying(){
  if(state === "ready"){
    state = "playing";
    lastSpawn = performance.now();
    lastPuff = performance.now();
    fetchGlobalBoard(); // refresh board when someone starts
  }
}

function die(){
  if(state !== "dead"){
    state = "dead";
    submitScore(score); // local
    submitGlobalScore(getPlayerName(), score); // global
  }
}

// ---------- Local leaderboard ----------
function getBest(){
  return Number(localStorage.getItem(STORAGE.best) || 0);
}
function setBest(v){
  localStorage.setItem(STORAGE.best, String(v));
}
function getBoard(){
  try{
    const a = JSON.parse(localStorage.getItem(STORAGE.board) || "[]");
    return Array.isArray(a) ? a : [];
  }catch{ return []; }
}
function setBoard(a){
  localStorage.setItem(STORAGE.board, JSON.stringify(a));
}
function submitScore(v){
  const best = getBest();
  if(v > best) setBest(v);

  const board = getBoard();
  board.push(v);
  board.sort((a,b)=>b-a);
  setBoard(board.slice(0,5));
}

// ---------- Collision helpers ----------
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function circleRectCollides(cx, cy, cr, rx, ry, rw, rh){
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx*dx + dy*dy) <= cr*cr;
}

// ---------- Pipes ----------
function spawnPipe(now){
  const gap = TUNING.gap;
  const topMin = UI.topBarH + 90;
  const bottomMin = 90;

  const gapTop = Math.floor(topMin + Math.random() * (H - topMin - bottomMin - gap));
  const gapBottom = gapTop + gap;

  pipes.push({
    x: W + 60,
    gapTop,
    gapBottom,
    scored:false
  });
  lastSpawn = now;
}

function updateDifficulty(){
  // Light difficulty scale based on score: faster + smaller gap
  const s = score;
  const speed = clamp(TUNING.pipeSpeed + s*0.05, TUNING.pipeSpeed, TUNING.maxSpeed);
  const gap = clamp(TUNING.gap - s*1.5, TUNING.minGap, TUNING.gap);
  return { speed, gap };
}

// ---------- Puffs ----------
function addPuff(){
  puffs.push({
    x: bird.x - bird.r - 8,
    y: bird.y + 6,
    t: performance.now(),
    vx: -1.4 - Math.random()*0.8,
    vy: (Math.random()-0.5)*0.5,
    s: 10 + Math.random()*10
  });
}
function updatePuffs(now){
  puffs = puffs.filter(p => now - p.t < TUNING.puffLife);
  for(const p of puffs){
    p.x += p.vx;
    p.y += p.vy;
    p.s *= 0.992;
  }
}

// ---------- Update loop ----------
function update(dt, now){
  const diff = updateDifficulty();
  const speed = diff.speed;

  // gravity
  if(state === "playing"){
    bird.v += TUNING.gravity;
    bird.y += bird.v;

    // puffs while playing (plus extra on flap)
    if(now - lastPuff > TUNING.puffEvery){
      addPuff();
      lastPuff = now;
    }

    // spawn
    if(now - lastSpawn > TUNING.spawnEvery){
      spawnPipe(now);
    }

    // move pipes
    for(const p of pipes){
      p.x -= speed;
      // scoring when pipe passes bird
      if(!p.scored && p.x + TUNING.pipeW/2 < bird.x){
        score++;
        p.scored = true;
      }

      // collision with columns + caps (toilet heads)
      const w = TUNING.pipeW;
      const left = p.x - w/2;

      // main top/bottom columns
      if(circleRectCollides(bird.x, bird.y, bird.r, left, 0, w, p.gapTop)) die();
      if(circleRectCollides(bird.x, bird.y, bird.r, left, p.gapBottom, w, H - p.gapBottom)) die();

      // cap hitboxes (toilet heads are solid too)
      const capW = TUNING.capW;
      const capH = TUNING.capH;
      const capLeft = p.x - capW/2;

      // top cap sits at bottom of top column and extends into gap
      const topCapY = p.gapTop - (capH - TUNING.capInset);
      if(circleRectCollides(bird.x, bird.y, bird.r, capLeft, topCapY, capW, capH)) die();

      // bottom cap sits at top of bottom column and extends into gap
      const bottomCapY = p.gapBottom - TUNING.capInset;
      if(circleRectCollides(bird.x, bird.y, bird.r, capLeft, bottomCapY, capW, capH)) die();
    }

    // cleanup pipes
    pipes = pipes.filter(p => p.x > -160);

    // bounds
    if(bird.y < -40 || bird.y > H + 40) die();
  }

  updatePuffs(now);
}

// ---------- Input ----------
function flapOrStartOrRestart(){
  fartSound();

  if(state === "ready"){
    startPlaying();
    bird.v = TUNING.flapImpulse;
    addPuff(); addPuff();
    return;
  }
  if(state === "dead"){
    reset();
    startPlaying();
    bird.v = TUNING.flapImpulse;
    addPuff(); addPuff();
    return;
  }
  if(state === "playing"){
    bird.v = TUNING.flapImpulse;
    addPuff(); addPuff();
  }
}

document.addEventListener("keydown", (e) => {
  if(e.code === "Space") flapOrStartOrRestart();
});
canvas.addEventListener("mousedown", flapOrStartOrRestart);
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  flapOrStartOrRestart();
}, { passive:false });

// ---------- Drawing ----------
function drawSewerBackground(){
  // base
  ctx.fillStyle = "#102018";
  ctx.fillRect(0,0,W,H);

  // bricks
  const brickW = 62;
  const brickH = 32;
  ctx.globalAlpha = 0.30;
  for(let y=0;y<H;y+=brickH){
    const offset = (Math.floor(y/brickH)%2)* (brickW/2);
    for(let x=-offset;x<W;x+=brickW){
      ctx.fillStyle = "#0b1510";
      ctx.fillRect(x+1, y+1, brickW-3, brickH-3);
    }
  }
  ctx.globalAlpha = 1;

  // slime drips
  ctx.globalAlpha = 0.20;
  for(let i=0;i<10;i++){
    const x = (i*47) % W;
    const h = 40 + (i*13)%90;
    ctx.fillStyle = "#4ea66a";
    ctx.fillRect(x, UI.topBarH, 12, h);
  }
  ctx.globalAlpha = 1;

  // vignette
  const g = ctx.createRadialGradient(W/2,H/2,100,W/2,H/2,520);
  g.addColorStop(0,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,0.55)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

function drawTopBar(){
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(0,0,W,UI.topBarH);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "20px system-ui,-apple-system,Arial";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";
  ctx.fillText(`Score: ${score}`, 16, UI.topBarH/2);

  ctx.textAlign = "right";
  ctx.fillText(`Best: ${getBest()}`, W-16, UI.topBarH/2);
}

function drawToiletColumn(xCenter, topY, height){
  // a sleek white column with slight gradient
  const w = TUNING.pipeW;
  const left = xCenter - w/2;

  const grad = ctx.createLinearGradient(left,0,left+w,0);
  grad.addColorStop(0,"#f7f7f7");
  grad.addColorStop(0.5,"#ffffff");
  grad.addColorStop(1,"#ececec");

  ctx.fillStyle = grad;
  ctx.fillRect(left, topY, w, height);

  // subtle edge
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#000";
  ctx.fillRect(left, topY, 2, height);
  ctx.fillRect(left+w-2, topY, 2, height);
  ctx.globalAlpha = 1;
}

function drawToiletHead(xCenter, yTop, isTop){
  // Draw a stylized toilet “head” as a cap
  const w = TUNING.capW;
  const h = TUNING.capH;
  const left = xCenter - w/2;

  // body
  ctx.fillStyle = "#f9f9f9";
  roundRect(left, yTop, w, h, 14, true);

  // bowl opening
  ctx.fillStyle = "#cfe6ff";
  roundRect(left + w*0.30, yTop + h*0.42, w*0.40, h*0.38, 12, true);

  // tank hint
  ctx.globalAlpha = 0.20;
  ctx.fillStyle = "#000";
  roundRect(left + w*0.18, yTop + h*0.12, w*0.64, h*0.18, 10, true);
  ctx.globalAlpha = 1;

  // direction shadow
  ctx.globalAlpha = 0.20;
  ctx.fillStyle = "#000";
  if(isTop){
    roundRect(left+8, yTop+h-10, w-16, 10, 8, true);
  }else{
    roundRect(left+8, yTop, w-16, 10, 8, true);
  }
  ctx.globalAlpha = 1;
}

function drawPipes(){
  for(const p of pipes){
    const w = TUNING.pipeW;

    // top column (from 0..gapTop)
    drawToiletColumn(p.x, 0, p.gapTop);

    // bottom column (gapBottom..H)
    drawToiletColumn(p.x, p.gapBottom, H - p.gapBottom);

    // caps (toilet heads) — positioned to match hitboxes
    const topCapY = p.gapTop - (TUNING.capH - TUNING.capInset);
    drawToiletHead(p.x, topCapY, true);

    const bottomCapY = p.gapBottom - TUNING.capInset;
    drawToiletHead(p.x, bottomCapY, false);
  }
}

function drawPuffs(){
  const now = performance.now();
  for(const p of puffs){
    const age = now - p.t;
    const a = 1 - (age / TUNING.puffLife);
    ctx.globalAlpha = Math.max(0, a) * 0.7;
    ctx.fillStyle = "#d7d7d7";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.s*0.45, 0, Math.PI*2);
    ctx.arc(p.x+10, p.y+2, p.s*0.35, 0, Math.PI*2);
    ctx.arc(p.x-8, p.y+6, p.s*0.28, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawBird(){
  // Peach (butt)
  ctx.save();
  ctx.translate(bird.x, bird.y);

  // small tilt by velocity
  const ang = clamp(bird.v / 12, -0.55, 0.55);
  ctx.rotate(ang);

  // peach body
  ctx.beginPath();
  ctx.fillStyle = "#ffb36b";
  ctx.arc(0,0,bird.r,0,Math.PI*2);
  ctx.fill();

  // shading
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(5,3,bird.r*0.95,0,Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // butt crack
  ctx.strokeStyle = "rgba(120,40,0,0.35)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-2,-12);
  ctx.quadraticCurveTo(3,0,-2,12);
  ctx.stroke();

  // cheek highlight
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(-8,-7,6,0,Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.restore();
}

function roundRect(x,y,w,h,r,fill){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  if(fill) ctx.fill();
  else ctx.stroke();
}

function drawOverlayCard(){
  const card = {
    w: UI.cardW,
    h: UI.cardH,
    x: (W-UI.cardW)/2,
    y: 170
  };

  // backdrop
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  roundRect(card.x, card.y, card.w, card.h, UI.cardR, true);

  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  const title = (state === "dead") ? "GAME OVER" : "FLAPPY FART";
  ctx.font = "44px system-ui,-apple-system,Arial";
  ctx.fillText(title, W/2, card.y + 28);

  ctx.font = "18px system-ui,-apple-system,Arial";
  const hint = (state === "dead") ? "Click / Tap / Space to restart" : "Click / Tap / Space to start";
  ctx.fillText(hint, W/2, card.y + 92);

  // score line
  ctx.globalAlpha = 0.95;
  ctx.font = "20px system-ui,-apple-system,Arial";
  const sLine = (state === "dead") ? `Final Score: ${score}` : `Best: ${getBest()}`;
  ctx.fillText(sLine, W/2, card.y + 120);
  ctx.globalAlpha = 1;

  // leaderboard
  drawLeaderboard(card);

  return card;
}

function drawLocalLeaderboard(card){
  const board = getBoard();

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "16px system-ui,-apple-system,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Leaderboard (local)", W/2, card.y + 154);

  ctx.font = "18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  ctx.textAlign = "left";

  const left = card.x + 92;
  const right = card.x + card.w - 92;
  let y = card.y + 182;

  for(let i=0;i<5;i++){
    const v = board[i] ?? "—";
    ctx.fillText(`${i+1}.`, left, y);
    ctx.textAlign = "right";
    ctx.fillText(String(v), right, y);
    ctx.textAlign = "left";
    y += 22;
  }
}

function drawGlobalLeaderboard(card){
  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.font = "16px system-ui,-apple-system,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Global Leaderboard", W/2, card.y + 154);

  const left = card.x + 70;
  const right = card.x + card.w - 70;
  let y = card.y + 182;

  ctx.font = "16px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

  if(globalBoardStatus === "loading"){
    ctx.fillText("Loading…", W/2, y);
    return;
  }
  if(globalBoardStatus === "error"){
    ctx.fillText("Offline (showing local)", W/2, y);
    return;
  }

  ctx.textAlign = "left";
  for(let i=0;i<10;i++){
    const row = globalBoard[i];
    const name = row ? row.name : "—";
    const val = row ? row.score : "—";

    ctx.fillText(`${i+1}. ${name}`, left, y);
    ctx.textAlign = "right";
    ctx.fillText(String(val), right, y);
    ctx.textAlign = "left";
    y += 20;
  }
}

function drawLeaderboard(card){
  if(globalBoardStatus === "ready"){
    drawGlobalLeaderboard(card);
  }else{
    drawLocalLeaderboard(card);
  }
}

function draw(){
  drawSewerBackground();
  drawPipes();
  drawPuffs();
  drawBird();
  drawTopBar();

  if(state === "ready" || state === "dead"){
    drawOverlayCard();
  }
}

// ---------- Main loop ----------
let lastT = performance.now();
function loop(t){
  const dt = Math.min(32, t - lastT);
  lastT = t;

  update(dt, t);
  draw();

  requestAnimationFrame(loop);
}

// ---------- Start ----------
reset();
fetchGlobalBoard();
requestAnimationFrame(loop);
</script>
</body>
</html>
