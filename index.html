<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Flappy Fart</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; padding: 0;
      height: 100%;
      background: #9bd3d6;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #wrap {
      height: 100%;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 30%, rgba(255,255,255,0.18), rgba(0,0,0,0.0)),
                  linear-gradient(#a8dfe2, #79c4c8);
    }
    canvas {
      width: min(92vw, 430px);
      height: min(92vh, 760px);
      border-radius: 22px;
      box-shadow: 0 24px 80px rgba(0,0,0,0.35);
      background: #102018;
      touch-action: none;
    }
    .hint {
      position: fixed;
      left: 12px; bottom: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.75);
      user-select: none;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.35);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" aria-label="Flappy Fart"></canvas>
  </div>
  <div class="hint">Tap / Click / Space to flap</div>

<script>
(() => {
  // ---------------------------
  // Config / Tuning
  // ---------------------------
  const TUNING = {
    // world
    gravity: 0.42,
    flapImpulse: -7.6,

    // pipes
    pipeW: 82,
    gap: 172,
    speed: 2.45,
    spawnEvery: 1500, // ms between pipes (higher = farther apart)

    // toilet head (cap) hitbox
    capW: 108,
    capH: 64,
    capInset: 12,   // how far cap overlaps into the gap

    // difficulty bounds
    safeTop: 92,    // keep clear area below top bar
    safeBottom: 88, // keep clear area above bottom edge

    // visuals
    shakeOnDie: 6,
    puffEvery: 2,    // frames between puffs during flap
  };

  const STORAGE = {
    best: "flappyfart_best_v3",
    board: "flappyfart_board_v3",
    name: "flappyfart_name_v3",
  };

  // ---------------------------
  // Global leaderboard (SheetBest)
  // ---------------------------
  const SHEETBEST_URL = "https://api.sheetbest.com/sheets/0815363c-4408-4c6f-a17f-5be927d638de";

  let globalBoard = [];
  let globalBoardStatus = "loading"; // loading | ready | error

  async function fetchGlobalBoard(){
    globalBoardStatus = "loading";
    try{
      const res = await fetch(SHEETBEST_URL, { method: "GET" });
      const rows = await res.json();

      globalBoard = (Array.isArray(rows) ? rows : [])
        .map(r => ({
          name: (r.name ?? "anon").toString().slice(0, 18),
          score: Number(r.score ?? 0)
        }))
        .filter(r => Number.isFinite(r.score))
        .sort((a,b) => b.score - a.score)
        .slice(0, 5);

      globalBoardStatus = "ready";
    } catch(e){
      globalBoardStatus = "error";
    }
  }

  async function submitGlobalScore(name, score){
    // Keep it simple; SheetBest is not secure against cheating. Fine for fun.
    try{
      const payload = [{ name: (name || "anon").toString().slice(0,18), score: Number(score)||0, ts: Date.now() }];
      await fetch(SHEETBEST_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      // refresh list after submit
      fetchGlobalBoard();
    } catch(e){}
  }

  // ---------------------------
  // Canvas setup (HiDPI)
  // ---------------------------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  let W = 420, H = 760;
  function resize(){
    const cssW = canvas.getBoundingClientRect().width;
    const cssH = canvas.getBoundingClientRect().height;
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    W = Math.floor(cssW * dpr);
    H = Math.floor(cssH * dpr);

    canvas.width = W;
    canvas.height = H;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = true;
  }
  new ResizeObserver(resize).observe(canvas);
  resize();

  // ---------------------------
  // State
  // ---------------------------
  const UI = {
    topBarH: 56,
  };

  let state = "ready"; // ready | playing | dead
  let score = 0;
  let shake = 0;

  const bird = {
    x: 0, y: 0,
    r: 18,
    v: 0,
    rot: 0,
  };

  let pipes = [];
  let puffs = [];
  let lastSpawn = 0;
  let lastFrameTime = performance.now();
  let puffFrame = 0;

  // ---------------------------
  // Local leaderboard (top 5)
  // ---------------------------
  function getBest(){
    return Number(localStorage.getItem(STORAGE.best) || 0) || 0;
  }
  function setBest(v){
    localStorage.setItem(STORAGE.best, String(v));
  }

  function getBoard(){
    try{
      const arr = JSON.parse(localStorage.getItem(STORAGE.board) || "[]");
      return Array.isArray(arr) ? arr : [];
    } catch(e){
      return [];
    }
  }
  function setBoard(arr){
    localStorage.setItem(STORAGE.board, JSON.stringify(arr.slice(0,5)));
  }

  function submitLocalScore(s){
    const best = getBest();
    if(s > best) setBest(s);

    const b = getBoard().map(Number).filter(Number.isFinite);
    b.push(s);
    b.sort((a,b)=>b-a);
    setBoard(b.slice(0,5));
  }

  function getPlayerName(){
    let name = (localStorage.getItem(STORAGE.name) || "").trim();
    if(!name){
      name = prompt("Name for leaderboard?", "anon") || "anon";
      name = name.trim().slice(0,18) || "anon";
      localStorage.setItem(STORAGE.name, name);
    }
    return name;
  }

  // ---------------------------
  // Collision helpers
  // ---------------------------
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function circleRectCollides(cx, cy, cr, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx + rw);
    const ny = clamp(cy, ry, ry + rh);
    const dx = cx - nx;
    const dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  // ---------------------------
  // Visuals: Sewer background
  // ---------------------------
  function drawSewerBackground(){
    // base
    ctx.fillStyle = "#173123";
    ctx.fillRect(0,0,W,H);

    // subtle vignette
    const g = ctx.createRadialGradient(W*0.5, H*0.2, 40, W*0.5, H*0.2, Math.max(W,H));
    g.addColorStop(0, "rgba(255,255,255,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0.45)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // bricks
    const brickH = 44;
    const brickW = 86;
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    for(let y=0; y<H; y+=brickH){
      const offset = (Math.floor(y/brickH) % 2) ? brickW*0.45 : 0;
      for(let x=-brickW; x<W+brickW; x+=brickW){
        ctx.fillRect(x+offset, y + brickH-3, brickW-10, 2);
        ctx.fillRect(x+offset + brickW-10, y+6, 2, brickH-10);
      }
    }
    ctx.globalAlpha = 1;

    // slime drips
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "#7dff7d";
    for(let i=0;i<6;i++){
      const x = (i/6)*W + (Math.sin((performance.now()/1400)+(i*2))*18);
      const h = 140 + (i%2)*80;
      ctx.fillRect(x, UI.topBarH-10, 18, h);
    }
    ctx.globalAlpha = 1;
  }

  // ---------------------------
  // Visuals: Toilet pipe drawing
  // ---------------------------
  function drawToiletColumn(x, topY, h){
    // Column body (pipe)
    const w = TUNING.pipeW;

    const left = x - w/2;
    const right = x + w/2;

    // white porcelain gradient
    const g = ctx.createLinearGradient(left, 0, right, 0);
    g.addColorStop(0, "rgba(255,255,255,0.92)");
    g.addColorStop(0.35, "rgba(255,255,255,0.98)");
    g.addColorStop(1, "rgba(235,235,235,0.92)");

    ctx.fillStyle = g;
    ctx.fillRect(left, topY, w, h);

    // subtle edge shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.fillRect(left, topY, 2, h);
    ctx.fillRect(right-2, topY, 2, h);
    ctx.globalAlpha = 1;

    // inner highlight stripe
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "#fff";
    ctx.fillRect(left + w*0.18, topY+6, w*0.18, h-12);
    ctx.globalAlpha = 1;
  }

  function drawToiletHead(x, y, isTop){
    // "Toilet head" cap with tank + bowl look
    const capW = TUNING.capW;
    const capH = TUNING.capH;
    const left = x - capW/2;

    // porcelain gradient
    const g = ctx.createLinearGradient(left, 0, left+capW, 0);
    g.addColorStop(0, "rgba(250,250,250,0.92)");
    g.addColorStop(0.5, "rgba(255,255,255,0.98)");
    g.addColorStop(1, "rgba(235,235,235,0.92)");

    // main block
    ctx.fillStyle = g;
    ctx.beginPath();
    roundRect(left, y, capW, capH, 14);
    ctx.fill();

    // bowl area
    ctx.globalAlpha = 0.14;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    roundRect(left+18, y+22, capW-36, capH-34, 18);
    ctx.fill();
    ctx.globalAlpha = 1;

    // water oval
    ctx.fillStyle = "rgba(120,190,255,0.55)";
    ctx.beginPath();
    ctx.ellipse(x, y + capH*0.58, capW*0.20, capH*0.16, 0, 0, Math.PI*2);
    ctx.fill();

    // bolt
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.arc(x, y + 18, 5, 0, Math.PI*2);
    ctx.fill();

    // tiny shadow
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.fillRect(left, y + (isTop ? capH-2 : 0), capW, 2);
    ctx.globalAlpha = 1;
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawPipes(){
    for(const p of pipes){
      const w = TUNING.pipeW;

      // top column: 0 .. gapTop
      drawToiletColumn(p.x, 0, p.gapTop);

      // bottom column: gapBottom .. H
      drawToiletColumn(p.x, p.gapBottom, H - p.gapBottom);

      // caps (toilet heads) that extend into the gap
      const topCapY = p.gapTop - (TUNING.capH - TUNING.capInset);
      drawToiletHead(p.x, topCapY, true);

      const bottomCapY = p.gapBottom - TUNING.capInset;
      drawToiletHead(p.x, bottomCapY, false);
    }
  }

  // ---------------------------
  // Visuals: Butt bird + fart gas
  // ---------------------------
  function drawButt(){
    // Emoji butt (peach) with slight tilt
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(bird.rot);

    ctx.font = `${Math.floor(bird.r*2.2)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("ðŸ‘", 0, 0);

    ctx.restore();
  }

  function addPuff(){
    // "gassy" puffs with velocity + fade
    puffs.push({
      x: bird.x - bird.r - 10,
      y: bird.y + 6 + rand(-4,4),
      t: performance.now(),
      vx: -1.4 - Math.random()*0.8,
      vy: (Math.random()-0.5)*0.55,
      s: 12 + Math.random()*14,
    });
  }

  function drawPuffs(){
    const now = performance.now();
    for(let i=puffs.length-1; i>=0; i--){
      const f = puffs[i];
      const age = (now - f.t);
      const life = 520; // ms
      const k = age / life;
      if(k >= 1){
        puffs.splice(i,1);
        continue;
      }

      // animate
      f.x += f.vx * 1.6;
      f.y += f.vy * 1.6;

      const alpha = (1-k) * 0.38;
      const size = f.s * (0.70 + k*0.95);

      ctx.save();
      ctx.globalAlpha = alpha;

      // greenish gas
      const grad = ctx.createRadialGradient(f.x, f.y, 2, f.x, f.y, size);
      grad.addColorStop(0, "rgba(170,255,120,0.9)");
      grad.addColorStop(0.55, "rgba(120,255,160,0.35)");
      grad.addColorStop(1, "rgba(120,255,160,0.0)");

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(f.x, f.y, size*1.05, size*0.80, 0.25, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  // ---------------------------
  // UI drawing
  // ---------------------------
  function drawTopBar(){
    ctx.save();

    // bar background
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,W,UI.topBarH);

    // score
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "800 22px system-ui, -apple-system, Arial";
    ctx.textBaseline = "middle";
    ctx.textAlign = "left";
    ctx.fillText(`Score: ${score}`, 16, UI.topBarH/2);

    // best
    ctx.textAlign = "right";
    ctx.font = "700 16px system-ui, -apple-system, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.80)";
    ctx.fillText(`Best: ${getBest()}`, W - 16, UI.topBarH/2);

    ctx.restore();
  }

  function drawCenterCard(lines){
    const cardW = Math.min(W*0.86, 360);
    const cardH = Math.min(H*0.46, 340);
    const cardX = (W - cardW)/2;
    const cardY = (H - cardH)/2 - 8;

    // card
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(10,20,14,0.78)";
    ctx.beginPath();
    roundRect(cardX, cardY, cardW, cardH, 22);
    ctx.fill();

    // border
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;

    // title
    ctx.fillStyle = "rgba(255,255,255,0.96)";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.font = "900 44px system-ui, -apple-system, Arial";
    ctx.fillText(lines[0], W/2, cardY + 22);

    // subtitle
    ctx.font = "600 16px system-ui, -apple-system, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.fillText(lines[1], W/2, cardY + 78);

    // divider
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.fillRect(cardX + 24, cardY + 112, cardW - 48, 1);
    ctx.globalAlpha = 1;

    return { x: cardX, y: cardY, w: cardW, h: cardH };
  }

  function drawLocalLeaderboard(card){
    const board = getBoard();
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "700 15px system-ui, -apple-system, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("Leaderboard (local)", W/2, card.y + 128);

    ctx.font = "600 15px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.textAlign = "left";

    const left = card.x + 76;
    const right = card.x + card.w - 76;
    let y = card.y + 158;

    for(let i=0;i<5;i++){
      const v = board[i] ?? "â€”";
      ctx.fillStyle = "rgba(255,255,255,0.86)";
      ctx.fillText(`${i+1}.`, left, y);
      ctx.textAlign = "right";
      ctx.fillText(String(v), right, y);
      ctx.textAlign = "left";
      y += 22;
    }
  }

  function drawGlobalLeaderboard(card){
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "700 15px system-ui, -apple-system, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("Leaderboard (global)", W/2, card.y + 128);

    ctx.font = "600 14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    const left = card.x + 52;
    const right = card.x + card.w - 52;
    let y = card.y + 158;

    if(globalBoardStatus === "loading"){
      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.textAlign = "center";
      ctx.fillText("Loading...", W/2, y);
      return;
    }
    if(globalBoardStatus === "error"){
      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.textAlign = "center";
      ctx.fillText("Offline (showing local)", W/2, y);
      return;
    }

    ctx.textAlign = "left";
    for(let i=0;i<5;i++){
      const row = globalBoard[i];
      const name = row ? row.name : "â€”";
      const val = row ? row.score : "â€”";

      ctx.fillStyle = "rgba(255,255,255,0.86)";
      ctx.fillText(`${i+1}. ${name}`, left, y);
      ctx.textAlign = "right";
      ctx.fillText(String(val), right, y);
      ctx.textAlign = "left";
      y += 20;
    }
  }

  function drawLeaderboard(card){
    if(globalBoardStatus === "ready") drawGlobalLeaderboard(card);
    else drawLocalLeaderboard(card);
  }

  // ---------------------------
  // Audio (mobile-safe fart synth)
  // ---------------------------
  let audioCtx = null;

  function fartSound(){
    try {
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      // required for mobile
      if(audioCtx.state === "suspended"){
        audioCtx.resume().catch(()=>{});
      }

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filt = audioCtx.createBiquadFilter();

      const t = audioCtx.currentTime;

      // slightly randomized "fart"
      osc.type = "square";
      const f0 = 170 + Math.random()*35;
      osc.frequency.setValueAtTime(f0, t);
      osc.frequency.exponentialRampToValueAtTime(58 + Math.random()*10, t + 0.09);

      filt.type = "lowpass";
      filt.frequency.setValueAtTime(720, t);
      filt.frequency.exponentialRampToValueAtTime(240, t + 0.12);

      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.55, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

      osc.connect(filt);
      filt.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(t);
      osc.stop(t + 0.2);

    } catch(e) {}
  }

  // Extra mobile unlock: first touch resumes audio context
  document.addEventListener("touchstart", () => {
    try{
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if(audioCtx.state === "suspended"){
        audioCtx.resume().catch(()=>{});
      }
    } catch(e){}
  }, { once: true, passive: true });

  // ---------------------------
  // Game flow
  // ---------------------------
  function reset(){
    state = "ready";
    score = 0;
    shake = 0;

    bird.x = W * 0.30;
    bird.y = H * 0.52;
    bird.v = 0;
    bird.rot = 0;

    pipes = [];
    puffs = [];
    lastSpawn = performance.now();
    puffFrame = 0;
  }

  function startPlaying(){
    if(state === "playing") return;
    state = "playing";
    lastSpawn = performance.now();
    // refresh global list at start
    fetchGlobalBoard();
  }

  function die(){
    if(state === "dead") return;
    state = "dead";
    shake = TUNING.shakeOnDie;

    submitLocalScore(score);

    // submit global
    const name = getPlayerName();
    submitGlobalScore(name, score);
  }

  function spawnPipe(){
    const gap = TUNING.gap;

    const topMin = UI.topBarH + TUNING.safeTop;
    const bottomMin = TUNING.safeBottom;

    // choose a gap top within safe bounds
    const maxGapTop = H - bottomMin - gap;
    const gapTop = Math.floor(rand(topMin, maxGapTop));
    const gapBottom = gapTop + gap;

    pipes.push({
      x: W + 80,
      gapTop,
      gapBottom,
      scored: false,
    });
  }

  function update(dtMs){
    const dt = dtMs / 16.6667;

    // camera shake
    if(shake > 0) shake = Math.max(0, shake - 0.35*dt);

    if(state === "playing"){
      // bird physics
      bird.v += TUNING.gravity * dt;
      bird.y += bird.v * dt;

      // rotate with velocity
      bird.rot = clamp(bird.v / 18, -0.45, 0.75);

      // spawn pipes
      const now = performance.now();
      if(now - lastSpawn >= TUNING.spawnEvery){
        spawnPipe();
        lastSpawn = now;
      }

      // move pipes
      for(const p of pipes){
        p.x -= TUNING.speed * dt * 3.0;
        if(!p.scored && p.x + TUNING.pipeW/2 < bird.x){
          p.scored = true;
          score++;
        }
      }
      // cleanup
      pipes = pipes.filter(p => p.x > -160);

      // collisions
      for(const p of pipes){
        const w = TUNING.pipeW;
        const left = p.x - w/2;

        // main columns
        if(circleRectCollides(bird.x, bird.y, bird.r, left, 0, w, p.gapTop)) die();
        if(circleRectCollides(bird.x, bird.y, bird.r, left, p.gapBottom, w, H - p.gapBottom)) die();

        // cap hitboxes (toilet heads)
        const capW = TUNING.capW;
        const capH = TUNING.capH;
        const capLeft = p.x - capW/2;

        // top cap sits at bottom of top column and extends into the gap
        const topCapY = p.gapTop - (capH - TUNING.capInset);
        if(circleRectCollides(bird.x, bird.y, bird.r, capLeft, topCapY, capW, capH)) die();

        // bottom cap sits at top of bottom column and extends into the gap
        const bottomCapY = p.gapBottom - TUNING.capInset;
        if(circleRectCollides(bird.x, bird.y, bird.r, capLeft, bottomCapY, capW, capH)) die();
      }

      // bounds
      if(bird.y < -40 || bird.y > H + 40) die();
    }
  }

  function draw(){
    // shake translate
    let sx = 0, sy = 0;
    if(shake > 0){
      sx = (Math.random()-0.5)*shake*2;
      sy = (Math.random()-0.5)*shake*2;
    }

    ctx.save();
    ctx.translate(sx, sy);

    drawSewerBackground();
    drawPipes();
    drawPuffs();
    drawButt();
    drawTopBar();

    // overlays
    if(state === "ready"){
      const card = drawCenterCard(["FLAPPY FART", "Tap / Click / Space to start"]);
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "700 16px system-ui, -apple-system, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText("Try not to bonk the toilets.", W/2, card.y + card.h - 52);
      ctx.globalAlpha = 1;
    }

    if(state === "dead"){
      const card = drawCenterCard(["GAME OVER", "Tap / Click / Space to restart"]);
      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.font = "800 18px system-ui, -apple-system, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(`Final Score: ${score}`, W/2, card.y + 100);

      drawLeaderboard(card);
    }

    ctx.restore();
  }

  function loop(now){
    const dt = Math.min(40, now - lastFrameTime);
    lastFrameTime = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ---------------------------
  // Input
  // ---------------------------
  function flapOrStartOrRestart(){
    // Sound must happen inside user gesture for mobile
    fartSound();

    if(state === "ready"){
      startPlaying();
      bird.v = TUNING.flapImpulse;
      // add a few puffs on start
      for(let i=0;i<3;i++) addPuff();
      return;
    }
    if(state === "dead"){
      reset();
      startPlaying();
      bird.v = TUNING.flapImpulse;
      for(let i=0;i<3;i++) addPuff();
      return;
    }
    // playing
    bird.v = TUNING.flapImpulse;

    // puff burst
    puffFrame = 0;
    for(let i=0;i<2;i++) addPuff();
  }

  document.addEventListener("keydown", (e) => {
    if(e.code === "Space"){
      e.preventDefault();
      flapOrStartOrRestart();
    }
  }, { passive: false });

  canvas.addEventListener("mousedown", (e) => {
    e.preventDefault();
    flapOrStartOrRestart();
  });

  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    flapOrStartOrRestart();
  }, { passive: false });

  // Emit puffs while the bird is moving up (for extra gassy feel)
  function puffTicker(){
    if(state === "playing" && bird.v < -1.4){
      puffFrame++;
      if(puffFrame % TUNING.puffEvery === 0) addPuff();
    }
    requestAnimationFrame(puffTicker);
  }

  // ---------------------------
  // Start
  // ---------------------------
  reset();
  fetchGlobalBoard();
  loop(performance.now());
  puffTicker();
})();
</script>
</body>
</html>
