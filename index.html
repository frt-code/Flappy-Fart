<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Flappy Fart</title>
  <style>
    :root{
      --frame:#7ad0d6;
      --bg:#0e1a14;
    }
    html,body{height:100%;margin:0;background:var(--frame);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{display:grid;place-items:center;}
    .wrap{
      width:min(460px,92vw);
      aspect-ratio: 9/16;
      background:rgba(0,0,0,0.15);
      border-radius:22px;
      box-shadow: 0 24px 80px rgba(0,0,0,.45);
      padding:14px;
    }
    canvas{
      width:100%;
      height:100%;
      border-radius:18px;
      background:var(--bg);
      display:block;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="450" height="800"></canvas>
  </div>

<script>
/* =========================
   Flappy Fart — single file
   ========================= */

const W = 450;
const H = 800;

const TUNING = {
  gravity: 0.52,
  flapImpulse: -8.8,

  pipeSpeed: 3.35,
  spawnEvery: 1250,     // ms
  gap: 210,             // starting gap
  pipeW: 96,

  // Toilet head (cap) hitboxes
  capW: 132,
  capH: 54,
  capInset: 18,         // bigger = harder (cap extends more into gap)

  // difficulty limits
  minGap: 150,
  maxSpeed: 5.4,

  // fart puffs
  puffEvery: 70,        // ms while playing
  puffLife: 720         // ms
};

const UI = {
  topBarH: 62,
  cardW: 360,
  cardH: 360,
  cardR: 18
};

const STORAGE = {
  best: "flappyfart_best_v2",
  board: "flappyfart_board_v2",
  name: "ff_name_v1",
};

// ---------- Global Leaderboard (SheetBest) ----------
const SHEETBEST_URL = "https://api.sheetbest.com/sheets/0815363c-4408-4c6f-a17f-5be927d638de";

let globalBoard = [];
let globalBoardStatus = "loading";

async function fetchGlobalBoard(){
  globalBoardStatus = "loading";
  try{
    const res = await fetch(SHEETBEST_URL, { cache: "no-store" });
    const rows = await res.json();

    globalBoard = rows
      .map(r => ({ name: (r.name || "anon"), score: Number(r.score || 0) }))
      .filter(r => Number.isFinite(r.score))
      .sort((a,b)=>b.score-a.score)
      .slice(0,10);

    globalBoardStatus = "ready";
  }catch(e){
    globalBoardStatus = "error";
  }
}

async function submitGlobalScore(name, score){
  try{
    await fetch(SHEETBEST_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({
        name: (name || "anon").slice(0,16),
        score,
        created_at: new Date().toISOString()
      })
    });
    fetchGlobalBoard();
  }catch(e){
    // ignore
  }
}

function getPlayerName(){
  let n = localStorage.getItem(STORAGE.name);
  if(!n){
    n = prompt("Name for global leaderboard:", "anon") || "anon";
    n = (n.trim() || "anon").slice(0,16);
    localStorage.setItem(STORAGE.name, n);
  }
  return n;
}

// ---------- Canvas ----------
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// ---------- Audio (simple fart synth) ----------
let audioCtx = null;
function fartSound(){
  try{
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const t = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();

    osc.type = "square";
    osc.frequency.setValueAtTime(160, t);
    osc.frequency.exponentialRampToValueAtTime(55, t + 0.09);

    filt.type = "lowpass";
    filt.frequency.setValueAtTime(900, t);
    filt.frequency.exponentialRampToValueAtTime(180, t + 0.12);

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.22, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);

    osc.connect(filt);
    filt.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(t);
    osc.stop(t + 0.18);
  }catch(e){}
}

// ---------- Helpers ----------
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

function circleRectCollides(cx, cy, cr, rx, ry, rw, rh){
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx*dx + dy*dy) <= cr*cr;
}

function roundRect(x,y,w,h,r,fill){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  if(fill) ctx.fill();
  else ctx.stroke();
}

// ---------- Local leaderboard ----------
function getBest(){ return Number(localStorage.getItem(STORAGE.best) || 0); }
function setBest(v){ localStorage.setItem(STORAGE.best, String(v)); }

function getBoard(){
  try{
    const a = JSON.parse(localStorage.getItem(STORAGE.board) || "[]");
    return Array.isArray(a) ? a : [];
  }catch{ return []; }
}
function setBoard(a){ localStorage.setItem(STORAGE.board, JSON.stringify(a)); }

function submitScore(v){
  if(v > getBest()) setBest(v);
  const board = getBoard();
  board.push(v);
  board.sort((a,b)=>b-a);
  setBoard(board.slice(0,5));
}

// ---------- Game State ----------
let state = "ready"; // ready | playing | dead
let score = 0;
let pipes = [];
let puffs = [];
let lastSpawn = 0;
let lastPuff = 0;

const bird = {
  x: 145,
  y: H*0.5,
  r: 22,
  v: 0
};

function reset(){
  state = "ready";
  score = 0;
  pipes = [];
  puffs = [];
  bird.x = 145;
  bird.y = H*0.5;
  bird.v = 0;
  lastSpawn = performance.now();
  lastPuff = performance.now();
}

function startPlaying(){
  if(state === "ready"){
    state = "playing";
    lastSpawn = performance.now();
    lastPuff = performance.now();
    fetchGlobalBoard();
  }
}

function die(){
  if(state !== "dead"){
    state = "dead";
    submitScore(score);
    submitGlobalScore(getPlayerName(), score);
  }
}

// ---------- Difficulty ----------
function difficulty(){
  const s = score;
  const speed = clamp(TUNING.pipeSpeed + s*0.05, TUNING.pipeSpeed, TUNING.maxSpeed);
  const gap = clamp(TUNING.gap - s*1.5, TUNING.minGap, TUNING.gap);
  return { speed, gap };
}

// ---------- Pipes ----------
function spawnPipe(now){
  const gap = difficulty().gap;
  const topMin = UI.topBarH + 90;
  const bottomMin = 90;
  const gapTop = Math.floor(topMin + Math.random() * (H - topMin - bottomMin - gap));
  const gapBottom = gapTop + gap;

  pipes.push({ x: W + 60, gapTop, gapBottom, scored:false });
  lastSpawn = now;
}

// ---------- Puffs (YOUR EDIT TARGET ✅) ----------
function addPuff(){
  // Updated to look more like fart gas: bigger, faster, more chaotic
  puffs.push({
    x: bird.x - bird.r * 1.2,
    y: bird.y + (Math.random()*8 - 4),
    t: performance.now(),
    vx: -2.2 - Math.random()*1.4,
    vy: (Math.random()-0.5)*1.2,
    s: 14 + Math.random()*18
  });
}

function updatePuffs(now){
  puffs = puffs.filter(p => (now - p.t) < TUNING.puffLife);
  for(const p of puffs){
    // drift + wobble = stink cloud feel
    p.x += p.vx;
    p.y += p.vy + Math.sin((now - p.t) * 0.02) * 0.35;
    p.s *= 0.992;
    p.vx *= 0.995;
    p.vy *= 0.995;
  }
}

// ---------- Update ----------
function update(now){
  if(state === "playing"){
    bird.v += TUNING.gravity;
    bird.y += bird.v;

    if(now - lastPuff > TUNING.puffEvery){
      addPuff();
      lastPuff = now;
    }

    if(now - lastSpawn > TUNING.spawnEvery){
      spawnPipe(now);
    }

    const speed = difficulty().speed;

    for(const p of pipes){
      p.x -= speed;

      if(!p.scored && p.x + TUNING.pipeW/2 < bird.x){
        score++;
        p.scored = true;
      }

      const w = TUNING.pipeW;
      const left = p.x - w/2;

      // main columns
      if(circleRectCollides(bird.x, bird.y, bird.r, left, 0, w, p.gapTop)) die();
      if(circleRectCollides(bird.x, bird.y, bird.r, left, p.gapBottom, w, H - p.gapBottom)) die();

      // cap hitboxes (toilet heads are solid too)
      const capW = TUNING.capW;
      const capH = TUNING.capH;
      const capLeft = p.x - capW/2;

      const topCapY = p.gapTop - (capH - TUNING.capInset);
      if(circleRectCollides(bird.x, bird.y, bird.r, capLeft, topCapY, capW, capH)) die();

      const bottomCapY = p.gapBottom - TUNING.capInset;
      if(circleRectCollides(bird.x, bird.y, bird.r, capLeft, bottomCapY, capW, capH)) die();
    }

    pipes = pipes.filter(p => p.x > -160);

    if(bird.y < -40 || bird.y > H + 40) die();
  }

  updatePuffs(now);
}

// ---------- Input ----------
function flapOrStartOrRestart(){
  fartSound();

  if(state === "ready"){
    startPlaying();
    bird.v = TUNING.flapImpulse;
    addPuff(); addPuff();
    return;
  }
  if(state === "dead"){
    reset();
    startPlaying();
    bird.v = TUNING.flapImpulse;
    addPuff(); addPuff();
    return;
  }
  if(state === "playing"){
    bird.v = TUNING.flapImpulse;
    addPuff(); addPuff();
  }
}

document.addEventListener("keydown", (e) => {
  if(e.code === "Space") flapOrStartOrRestart();
});
canvas.addEventListener("mousedown", flapOrStartOrRestart);
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  flapOrStartOrRestart();
}, { passive:false });

// ---------- Draw ----------
function drawSewerBackground(){
  ctx.fillStyle = "#102018";
  ctx.fillRect(0,0,W,H);

  // bricks
  const brickW = 62;
  const brickH = 32;
  ctx.globalAlpha = 0.30;
  for(let y=0;y<H;y+=brickH){
    const offset = (Math.floor(y/brickH)%2) * (brickW/2);
    for(let x=-offset;x<W;x+=brickW){
      ctx.fillStyle = "#0b1510";
      ctx.fillRect(x+1, y+1, brickW-3, brickH-3);
    }
  }
  ctx.globalAlpha = 1;

  // slime drips
  ctx.globalAlpha = 0.20;
  for(let i=0;i<10;i++){
    const x = (i*47) % W;
    const h = 40 + (i*13)%90;
    ctx.fillStyle = "#4ea66a";
    ctx.fillRect(x, UI.topBarH, 12, h);
  }
  ctx.globalAlpha = 1;

  // vignette
  const g = ctx.createRadialGradient(W/2,H/2,100,W/2,H/2,520);
  g.addColorStop(0,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,0.55)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
}

function drawTopBar(){
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(0,0,W,UI.topBarH);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "20px system-ui,-apple-system,Arial";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";
  ctx.fillText(`Score: ${score}`, 16, UI.topBarH/2);

  ctx.textAlign = "right";
  ctx.fillText(`Best: ${getBest()}`, W-16, UI.topBarH/2);
}

function drawToiletColumn(xCenter, topY, height){
  const w = TUNING.pipeW;
  const left = xCenter - w/2;

  const grad = ctx.createLinearGradient(left,0,left+w,0);
  grad.addColorStop(0,"#f7f7f7");
  grad.addColorStop(0.5,"#ffffff");
  grad.addColorStop(1,"#ececec");

  ctx.fillStyle = grad;
  ctx.fillRect(left, topY, w, height);

  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#000";
  ctx.fillRect(left, topY, 2, height);
  ctx.fillRect(left+w-2, topY, 2, height);
  ctx.globalAlpha = 1;
}

function drawToiletHead(xCenter, yTop, isTop){
  const w = TUNING.capW;
  const h = TUNING.capH;
  const left = xCenter - w/2;

  ctx.fillStyle = "#f9f9f9";
  roundRect(left, yTop, w, h, 14, true);

  ctx.fillStyle = "#cfe6ff";
  roundRect(left + w*0.30, yTop + h*0.42, w*0.40, h*0.38, 12, true);

  ctx.globalAlpha = 0.20;
  ctx.fillStyle = "#000";
  roundRect(left + w*0.18, yTop + h*0.12, w*0.64, h*0.18, 10, true);
  ctx.globalAlpha = 1;

  ctx.globalAlpha = 0.20;
  ctx.fillStyle = "#000";
  if(isTop){
    roundRect(left+8, yTop+h-10, w-16, 10, 8, true);
  }else{
    roundRect(left+8, yTop, w-16, 10, 8, true);
  }
  ctx.globalAlpha = 1;
}

function drawPipes(){
  for(const p of pipes){
    drawToiletColumn(p.x, 0, p.gapTop);
    drawToiletColumn(p.x, p.gapBottom, H - p.gapBottom);

    const topCapY = p.gapTop - (TUNING.capH - TUNING.capInset);
    drawToiletHead(p.x, topCapY, true);

    const bottomCapY = p.gapBottom - TUNING.capInset;
    drawToiletHead(p.x, bottomCapY, false);
  }
}

// ✅ New fart-gas look (green stink clouds, lumpy blobs)
function drawPuffs(){
  const now = performance.now();

  for(const p of puffs){
    const age = now - p.t;
    const a = 1 - (age / TUNING.puffLife);
    const alpha = Math.max(0, a);

    ctx.save();
    ctx.globalAlpha = alpha * 0.9;

    const wob = Math.sin(age * 0.02) * 2;

    // green stink gradient
    const g = ctx.createRadialGradient(p.x, p.y, 2, p.x, p.y, p.s * 1.6);
    g.addColorStop(0, "#d4ff6a");
    g.addColorStop(0.55, "#9be23a");
    g.addColorStop(1, "#4f7f1a");

    ctx.fillStyle = g;

    // lumpy cloud
    ctx.beginPath();
    ctx.arc(p.x - p.s*0.35, p.y + wob, p.s*0.55, 0, Math.PI*2);
    ctx.arc(p.x + p.s*0.35, p.y - wob, p.s*0.65, 0, Math.PI*2);
    ctx.arc(p.x, p.y, p.s*0.70, 0, Math.PI*2);
    ctx.fill();

    // darker stink spot
    ctx.globalAlpha = alpha * 0.35;
    ctx.fillStyle = "#2f4a0f";
    ctx.beginPath();
    ctx.arc(p.x + p.s*0.15, p.y + 2, p.s*0.18, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }
}

// ✅ Butt bird
function drawBird(){
  ctx.save();
  ctx.translate(bird.x, bird.y);

  const ang = clamp(bird.v / 12, -0.6, 0.6);
  ctx.rotate(ang);

  const r = bird.r;

  // cheeks gradients
  const gradL = ctx.createRadialGradient(-r*0.4, -r*0.3, 2, -r*0.2, 0, r);
  gradL.addColorStop(0, "#ffc78f");
  gradL.addColorStop(1, "#ff9e5e");

  const gradR = ctx.createRadialGradient(r*0.4, -r*0.3, 2, r*0.2, 0, r);
  gradR.addColorStop(0, "#ffc78f");
  gradR.addColorStop(1, "#ff9e5e");

  // left cheek
  ctx.fillStyle = gradL;
  ctx.beginPath();
  ctx.arc(-r*0.35, 0, r*0.95, 0, Math.PI*2);
  ctx.fill();

  // right cheek
  ctx.fillStyle = gradR;
  ctx.beginPath();
  ctx.arc(r*0.35, 0, r*0.95, 0, Math.PI*2);
  ctx.fill();

  // center blend
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "#ffb07a";
  ctx.beginPath();
  ctx.ellipse(0, 0, r*0.9, r*0.8, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // crack
  ctx.strokeStyle = "rgba(120,40,0,0.45)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, -r*0.9);
  ctx.quadraticCurveTo(2, 0, 0, r*0.9);
  ctx.stroke();

  // highlight
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(-r*0.55, -r*0.35, r*0.25, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.restore();
}

function drawOverlayCard(){
  const card = { w:UI.cardW, h:UI.cardH, x:(W-UI.cardW)/2, y:170 };

  ctx.fillStyle = "rgba(0,0,0,0.55)";
  roundRect(card.x, card.y, card.w, card.h, UI.cardR, true);

  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";

  const title = (state === "dead") ? "GAME OVER" : "FLAPPY FART";
  ctx.font = "44px system-ui,-apple-system,Arial";
  ctx.fillText(title, W/2, card.y + 28);

  ctx.font = "18px system-ui,-apple-system,Arial";
  const hint = (state === "dead") ? "Click / Tap / Space to restart" : "Click / Tap / Space to start";
  ctx.fillText(hint, W/2, card.y + 92);

  ctx.font = "20px system-ui,-apple-system,Arial";
  const sLine = (state === "dead") ? `Final Score: ${score}` : `Best: ${getBest()}`;
  ctx.fillText(sLine, W/2, card.y + 120);

  drawLeaderboard(card);
}

function drawLocalLeaderboard(card){
  const board = getBoard();

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "16px system-ui,-apple-system,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Leaderboard (local)", W/2, card.y + 154);

  ctx.font = "18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
  ctx.textAlign = "left";

  const left = card.x + 92;
  const right = card.x + card.w - 92;
  let y = card.y + 182;

  for(let i=0;i<5;i++){
    const v = board[i] ?? "—";
    ctx.fillText(`${i+1}.`, left, y);
    ctx.textAlign = "right";
    ctx.fillText(String(v), right, y);
    ctx.textAlign = "left";
    y += 22;
  }
}

function drawGlobalLeaderboard(card){
  ctx.fillStyle = "rgba(255,255,255,0.95)";
  ctx.font = "16px system-ui,-apple-system,Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("Global Leaderboard", W/2, card.y + 154);

  const left = card.x + 70;
  const right = card.x + card.w - 70;
  let y = card.y + 182;

  ctx.font = "16px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

  if(globalBoardStatus === "loading"){
    ctx.fillText("Loading…", W/2, y);
    return;
  }
  if(globalBoardStatus === "error"){
    ctx.fillText("Offline (showing local)", W/2, y);
    return;
  }

  ctx.textAlign = "left";
  for(let i=0;i<10;i++){
    const row = globalBoard[i];
    const name = row ? row.name : "—";
    const val = row ? row.score : "—";

    ctx.fillText(`${i+1}. ${name}`, left, y);
    ctx.textAlign = "right";
    ctx.fillText(String(val), right, y);
    ctx.textAlign = "left";
    y += 20;
  }
}

function drawLeaderboard(card){
  if(globalBoardStatus === "ready"){
    drawGlobalLeaderboard(card);
  }else{
    drawLocalLeaderboard(card);
  }
}

function draw(){
  drawSewerBackground();
  drawPipes();
  drawPuffs();
  drawBird();
  drawTopBar();

  if(state === "ready" || state === "dead"){
    drawOverlayCard();
  }
}

// ---------- Main loop ----------
function loop(t){
  update(t);
  draw();
  requestAnimationFrame(loop);
}

// ---------- Start ----------
reset();
fetchGlobalBoard();
requestAnimationFrame(loop);
</script>
</body>
</html>
